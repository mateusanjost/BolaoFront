import { __decorate, __metadata, __read, __assign, __extends } from 'tslib';
import { Input, Component, forwardRef, ViewEncapsulation, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatAutocompleteModule, MatFormFieldModule, MatInputModule, MatProgressSpinnerModule, MatTooltipModule } from '@angular/material';
import { Subject, BehaviorSubject, of, timer, EMPTY, combineLatest } from 'rxjs';
import { take, startWith, distinctUntilChanged, debounce, filter, switchMap, map, catchError, publishReplay, refCount, withLatestFrom } from 'rxjs/operators';

// Base class with which to create an observable auto complete. This doesn't
var SearchSelectBase = /** @class */ (function () {
    function SearchSelectBase() {
        var _this = this;
        this.debounceTime = 75;
        // API provided to client component (for use in its template)
        this.searchControl = new FormControl();
        // ---------------------------------------------------------------------
        // Internals
        // tslint:disable:member-ordering
        this.incomingValues = new Subject();
        this.incomingDataSources = new BehaviorSubject({
            displayValue: of,
            search: function () { return of([]); }
        });
        this.onChange = function (_) { };
        this.onTouched = function () { };
        var searches = this.searchControl.valueChanges.pipe(startWith(this.searchControl.value), distinctUntilChanged(), debounce(function (srch) {
            // Typing into input sends strings.
            if (typeof srch === 'string') {
                return timer(_this.debounceTime);
            }
            return EMPTY; // immediate - no debounce for choosing from the list
        }));
        var options = combineLatest(searches, this.incomingDataSources.pipe(filter(function (ds) { return !!ds; }))).pipe(switchMap(function (_a) {
            var _b = __read(_a, 2), srch = _b[0], ds = _b[1];
            // Initial value is sometimes null.
            if (srch === null) {
                srch = '';
            }
            // Typing into input sends strings.
            if (typeof srch === 'string') {
                var search_1 = srch;
                return ds.search(srch).pipe(map(function (list) { return ({ search: search_1, list: list }); }), catchError(function (errorMessage) { return of({ search: search_1, errorMessage: errorMessage }); }), startWith({ search: search_1 }));
            }
            // Selecting from Material Option List sends an object, so there is
            // no need to call function to search for it.
            var entry = srch;
            return of({
                search: srch.display,
                list: [__assign({}, entry)]
            });
        }), publishReplay(1), refCount());
        function matcher(search, entry) {
            return entry.display === search;
        }
        this.selectedValue = options.pipe(filter(function (result) { return !!result.list; }), withLatestFrom(this.incomingDataSources), map(function (_a) {
            var _b = __read(_a, 2), result = _b[0], ds = _b[1];
            var list = result.list || []; // appease TS
            var matchFn = ds.match || matcher;
            var entry = list.find(function (option) { return matchFn(result.search, option); });
            return entry && entry.value || null;
        }), distinctUntilChanged());
        this.loading = options.pipe(map(function (o) { return !o.list && !o.errorMessage; }));
        this.list = options.pipe(map(function (o) { return o.list; }));
        this.empty = options.pipe(map(function (o) { return o.list ? o.list.length === 0 : false; }));
        this.errorMessage = options.pipe(map(function (o) { return o.errorMessage; }));
        // a value was provided by the form; request the full entry
        this.incomingDataSourcesSub = this.incomingValues.pipe(withLatestFrom(this.incomingDataSources), switchMap(function (_a) {
            var _b = __read(_a, 2), value = _b[0], ds = _b[1];
            return ds.displayValue(value);
        }))
            .subscribe(function (value) { return _this.searchControl.setValue(value); });
    }
    Object.defineProperty(SearchSelectBase.prototype, "dataSource", {
        set: function (ds) { this.incomingDataSources.next(ds); },
        enumerable: true,
        configurable: true
    });
    SearchSelectBase.prototype.focus = function () {
        // While focused, user selection will be propagated to the form.
        this.selectedValueSub = this.selectedValue.subscribe(this.checkAndPropagate.bind(this));
    };
    SearchSelectBase.prototype.blur = function () {
        this.onTouched();
        // Now that we've lost focus, stop propagating changes.
        if (this.selectedValueSub) {
            this.selectedValueSub.unsubscribe();
        }
        // However, it's possible the user has just typed some text that will be
        // confirmed (by the application provided function) as a match,
        // asynchronously. We can't force the system to wait for that to happen, we
        // are losing focus right now. But we can subscribe to pick up that one last
        // change and propagate it if/when it arrives.
        this.selectedValue
            .pipe(take(1))
            .subscribe(this.checkAndPropagate.bind(this));
        // However, this code raises an important question about valid behavior of a
        // Angular form control. Is it acceptable for a form control to
        // asynchronously provide a new value when it no longer has focus?
    };
    SearchSelectBase.prototype.displayWith = function (value) {
        return value ? value.display : '';
    };
    // Implement ControlValueAccessor
    SearchSelectBase.prototype.writeValue = function (obj) {
        // Angular sometimes writes a value that didn't really change.
        if (obj !== this.outsideValue) {
            this.outsideValue = obj;
            this.incomingValues.next(obj);
        }
    };
    SearchSelectBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    SearchSelectBase.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    SearchSelectBase.prototype.setDisabledState = function (isDisabled) {
        if (isDisabled) {
            this.searchControl.disable();
        }
        else {
            this.searchControl.enable();
        }
    };
    SearchSelectBase.prototype.ngOnDestroy = function () {
        if (this.incomingDataSourcesSub) {
            this.incomingDataSourcesSub.unsubscribe();
        }
    };
    SearchSelectBase.prototype.checkAndPropagate = function (value) {
        // Only send a change if there really is one.
        if (value !== this.outsideValue) {
            this.outsideValue = value;
            this.onChange(value);
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SearchSelectBase.prototype, "debounceTime", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], SearchSelectBase.prototype, "dataSource", null);
    return SearchSelectBase;
}());

// The CSS approach below is the documented solution:
// https://github.com/angular/material2/issues/3810
// https://github.com/angular/material2/pull/7176
// To set the width, style the first class something like this:
// width: 400px;
// max-width: 400px !important;
// ... need to figure out how to set the number programmaticlly.
var SearchSelectComponent = /** @class */ (function (_super) {
    __extends(SearchSelectComponent, _super);
    function SearchSelectComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.debounceTime = 100;
        _this.width = '';
        _this.emptyText = '';
        _this.autoActiveFirstOption = false;
        return _this;
    }
    SearchSelectComponent_1 = SearchSelectComponent;
    var SearchSelectComponent_1;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SearchSelectComponent.prototype, "placeholder", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "debounceTime", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "emptyText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "autoActiveFirstOption", void 0);
    SearchSelectComponent = SearchSelectComponent_1 = __decorate([
        Component({
            selector: 'search-select',
            template: "<mat-form-field class=\"obs-mat-container\" [style.width]=\"width\">\n  <mat-spinner class=\"obs-mat-spinner\"\n    *ngIf=\"loading | async\"\n    [diameter]=\"20\"\n    [strokeWidth]=\"5\"></mat-spinner>\n  <i class=\"obs-no-matches\" *ngIf=\"emptyText && empty | async\">{{emptyText}}</i>\n  <input\n      type=\"text\"\n      [placeholder]=\"placeholder\"\n      [attr.aria-label]=\"placeholder\"\n      spellcheck=\"false\"\n      matInput\n      [formControl]=\"searchControl\"\n      #input\n      (blur)=\"blur()\"\n      (focus)=\"input.select(); focus()\"\n      [matAutocomplete]=\"auto\">\n  <mat-autocomplete #auto=\"matAutocomplete\" [displayWith]=\"displayWith\"\n    [autoActiveFirstOption]=\"autoActiveFirstOption\"\n   class=\"bigger-mat-ac\">\n    <mat-option *ngFor=\"let option of list | async\"\n      [value]=\"option\">\n      {{ option.display }}\n    </mat-option>\n  </mat-autocomplete>\n  <b>{{ errorMessage | async }}</b>\n</mat-form-field>\n",
            providers: [
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return SearchSelectComponent_1; }),
                    multi: true
                }
            ],
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [".bigger-mat-ac.mat-autocomplete-panel{max-height:500px!important}.obs-mat-container{position:relative}.obs-mat-container mat-spinner.obs-mat-spinner{position:absolute;right:5px}.obs-no-matches{position:absolute;color:silver;right:5px}.ng-invalid.ng-touched>.obs-mat-container,.ng-invalid.ng-touched>.obs-mat-container label{color:#f44336!important}"]
        })
    ], SearchSelectComponent);
    return SearchSelectComponent;
}(SearchSelectBase));

var SearchSelectModule = /** @class */ (function () {
    function SearchSelectModule() {
    }
    SearchSelectModule = __decorate([
        NgModule({
            imports: [
                CommonModule,
                MatAutocompleteModule,
                MatFormFieldModule,
                MatInputModule,
                MatProgressSpinnerModule,
                MatTooltipModule,
                FormsModule,
                ReactiveFormsModule
            ],
            declarations: [
                SearchSelectComponent
            ],
            exports: [
                SearchSelectComponent
            ]
        })
    ], SearchSelectModule);
    return SearchSelectModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { SearchSelectBase, SearchSelectModule, SearchSelectComponent as Éµa };
//# sourceMappingURL=oasisdigital-angular-material-search-select.js.map
