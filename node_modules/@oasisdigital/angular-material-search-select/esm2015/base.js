// Base class with which to create an observable auto complete. This doesn't
// have any connection to how the result is rendered in the Dom, with what
// component set, and so on.
import * as tslib_1 from "tslib";
import { Input } from '@angular/core';
import { FormControl } from '@angular/forms';
import { BehaviorSubject, of, EMPTY, timer, combineLatest, Subject } from 'rxjs';
import { switchMap, startWith, catchError, map, filter, debounce, take, refCount, withLatestFrom, publishReplay, distinctUntilChanged } from 'rxjs/operators';
export class SearchSelectBase {
    constructor() {
        this.debounceTime = 75;
        // API provided to client component (for use in its template)
        this.searchControl = new FormControl();
        // ---------------------------------------------------------------------
        // Internals
        // tslint:disable:member-ordering
        this.incomingValues = new Subject();
        this.incomingDataSources = new BehaviorSubject({
            displayValue: of,
            search: () => of([])
        });
        this.onChange = (_) => { };
        this.onTouched = () => { };
        const searches = this.searchControl.valueChanges.pipe(startWith(this.searchControl.value), distinctUntilChanged(), debounce(srch => {
            // Typing into input sends strings.
            if (typeof srch === 'string') {
                return timer(this.debounceTime);
            }
            return EMPTY; // immediate - no debounce for choosing from the list
        }));
        const options = combineLatest(searches, this.incomingDataSources.pipe(filter(ds => !!ds))).pipe(switchMap(([srch, ds]) => {
            // Initial value is sometimes null.
            if (srch === null) {
                srch = '';
            }
            // Typing into input sends strings.
            if (typeof srch === 'string') {
                const search = srch;
                return ds.search(srch).pipe(map(list => ({ search, list })), catchError(errorMessage => of({ search, errorMessage })), startWith({ search }));
            }
            // Selecting from Material Option List sends an object, so there is
            // no need to call function to search for it.
            const entry = srch;
            return of({
                search: srch.display,
                list: [Object.assign({}, entry)]
            });
        }), publishReplay(1), refCount());
        function matcher(search, entry) {
            return entry.display === search;
        }
        this.selectedValue = options.pipe(filter(result => !!result.list), withLatestFrom(this.incomingDataSources), map(([result, ds]) => {
            const list = result.list || []; // appease TS
            const matchFn = ds.match || matcher;
            const entry = list.find(option => matchFn(result.search, option));
            return entry && entry.value || null;
        }), distinctUntilChanged());
        this.loading = options.pipe(map(o => !o.list && !o.errorMessage));
        this.list = options.pipe(map(o => o.list));
        this.empty = options.pipe(map(o => o.list ? o.list.length === 0 : false));
        this.errorMessage = options.pipe(map(o => o.errorMessage));
        // a value was provided by the form; request the full entry
        this.incomingDataSourcesSub = this.incomingValues.pipe(withLatestFrom(this.incomingDataSources), switchMap(([value, ds]) => ds.displayValue(value)))
            .subscribe(value => this.searchControl.setValue(value));
    }
    set dataSource(ds) { this.incomingDataSources.next(ds); }
    focus() {
        // While focused, user selection will be propagated to the form.
        this.selectedValueSub = this.selectedValue.subscribe(this.checkAndPropagate.bind(this));
    }
    blur() {
        this.onTouched();
        // Now that we've lost focus, stop propagating changes.
        if (this.selectedValueSub) {
            this.selectedValueSub.unsubscribe();
        }
        // However, it's possible the user has just typed some text that will be
        // confirmed (by the application provided function) as a match,
        // asynchronously. We can't force the system to wait for that to happen, we
        // are losing focus right now. But we can subscribe to pick up that one last
        // change and propagate it if/when it arrives.
        this.selectedValue
            .pipe(take(1))
            .subscribe(this.checkAndPropagate.bind(this));
        // However, this code raises an important question about valid behavior of a
        // Angular form control. Is it acceptable for a form control to
        // asynchronously provide a new value when it no longer has focus?
    }
    displayWith(value) {
        return value ? value.display : '';
    }
    // Implement ControlValueAccessor
    writeValue(obj) {
        // Angular sometimes writes a value that didn't really change.
        if (obj !== this.outsideValue) {
            this.outsideValue = obj;
            this.incomingValues.next(obj);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.searchControl.disable();
        }
        else {
            this.searchControl.enable();
        }
    }
    ngOnDestroy() {
        if (this.incomingDataSourcesSub) {
            this.incomingDataSourcesSub.unsubscribe();
        }
    }
    checkAndPropagate(value) {
        // Only send a change if there really is one.
        if (value !== this.outsideValue) {
            this.outsideValue = value;
            this.onChange(value);
        }
    }
}
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], SearchSelectBase.prototype, "debounceTime", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], SearchSelectBase.prototype, "dataSource", null);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BvYXNpc2RpZ2l0YWwvYW5ndWxhci1tYXRlcmlhbC1zZWFyY2gtc2VsZWN0LyIsInNvdXJjZXMiOlsiYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBQzFFLDRCQUE0Qjs7QUFFNUIsT0FBTyxFQUFFLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNqRCxPQUFPLEVBQUUsV0FBVyxFQUF3QixNQUFNLGdCQUFnQixDQUFDO0FBQ25FLE9BQU8sRUFDcUIsZUFBZSxFQUFFLEVBQUUsRUFDN0MsS0FBSyxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUNyQyxNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUM3QyxRQUFRLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQ3hDLGFBQWEsRUFBRSxvQkFBb0IsRUFDcEMsTUFBTSxnQkFBZ0IsQ0FBQztBQVV4QixNQUFNLE9BQU8sZ0JBQWdCO0lBc0QzQjtRQXJEUyxpQkFBWSxHQUFHLEVBQUUsQ0FBQztRQUczQiw2REFBNkQ7UUFFN0Qsa0JBQWEsR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDO1FBa0NsQyx3RUFBd0U7UUFDeEUsWUFBWTtRQUNaLGlDQUFpQztRQUN6QixtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFPLENBQUM7UUFDcEMsd0JBQW1CLEdBQUcsSUFBSSxlQUFlLENBQWE7WUFDNUQsWUFBWSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7U0FDckIsQ0FBQyxDQUFDO1FBaUhLLGFBQVEsR0FBRyxDQUFDLENBQU0sRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLGNBQVMsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7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R0FBRyxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVELGdCQUFnQixDQUFDLFVBQW1CO1FBQ2xDLElBQUksVUFBVSxFQUFFO1lBQ2QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUM5QjthQUFNO1lBQ0wsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUM3QjtJQUNILENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsc0JBQXNCLEVBQUU7WUFDL0IsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzNDO0lBQ0gsQ0FBQztJQUtPLGlCQUFpQixDQUFDLEtBQVU7UUFDbEMsNkNBQTZDO1FBQzdDLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDL0IsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7WUFDMUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0QjtJQUNILENBQUM7Q0FDRjtBQXpLVTtJQUFSLEtBQUssRUFBRTs7c0RBQW1CO0FBQ2xCO0lBQVIsS0FBSyxFQUFFOzs7a0RBQXNFIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQmFzZSBjbGFzcyB3aXRoIHdoaWNoIHRvIGNyZWF0ZSBhbiBvYnNlcnZhYmxlIGF1dG8gY29tcGxldGUuIFRoaXMgZG9lc24ndFxuLy8gaGF2ZSBhbnkgY29ubmVjdGlvbiB0byBob3cgdGhlIHJlc3VsdCBpcyByZW5kZXJlZCBpbiB0aGUgRG9tLCB3aXRoIHdoYXRcbi8vIGNvbXBvbmVudCBzZXQsIGFuZCBzbyBvbi5cblxuaW1wb3J0IHsgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgU3Vic2NyaXB0aW9uLCBPYnNlcnZhYmxlLCBCZWhhdmlvclN1YmplY3QsIG9mLFxuICBFTVBUWSwgdGltZXIsIGNvbWJpbmVMYXRlc3QsIFN1YmplY3Rcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBzd2l0Y2hNYXAsIHN0YXJ0V2l0aCwgY2F0Y2hFcnJvciwgbWFwLCBmaWx0ZXIsXG4gIGRlYm91bmNlLCB0YWtlLCByZWZDb3VudCwgd2l0aExhdGVzdEZyb20sXG4gIHB1Ymxpc2hSZXBsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgT3B0aW9uRW50cnksIERhdGFTb3VyY2UgfSBmcm9tICcuL3R5cGVzJztcblxuaW50ZXJmYWNlIFNlYXJjaFJlc3VsdCB7XG4gIHNlYXJjaDogc3RyaW5nO1xuICBsaXN0PzogT3B0aW9uRW50cnlbXTtcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgU2VhcmNoU2VsZWN0QmFzZSBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkRlc3Ryb3kge1xuICBASW5wdXQoKSBkZWJvdW5jZVRpbWUgPSA3NTtcbiAgQElucHV0KCkgc2V0IGRhdGFTb3VyY2UoZHM6IERhdGFTb3VyY2UpIHsgdGhpcy5pbmNvbWluZ0RhdGFTb3VyY2VzLm5leHQoZHMpOyB9XG5cbiAgLy8gQVBJIHByb3ZpZGVkIHRvIGNsaWVudCBjb21wb25lbnQgKGZvciB1c2UgaW4gaXRzIHRlbXBsYXRlKVxuXG4gIHNlYXJjaENvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAgbG9hZGluZzogT2JzZXJ2YWJsZTxib29sZWFuPjtcbiAgbGlzdDogT2JzZXJ2YWJsZTxPcHRpb25FbnRyeVtdIHwgdW5kZWZpbmVkPjtcbiAgZW1wdHk6IE9ic2VydmFibGU8Ym9vbGVhbj47XG4gIGVycm9yTWVzc2FnZTogT2JzZXJ2YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuXG4gIGZvY3VzKCkge1xuICAgIC8vIFdoaWxlIGZvY3VzZWQsIHVzZXIgc2VsZWN0aW9uIHdpbGwgYmUgcHJvcGFnYXRlZCB0byB0aGUgZm9ybS5cbiAgICB0aGlzLnNlbGVjdGVkVmFsdWVTdWIgPSB0aGlzLnNlbGVjdGVkVmFsdWUuc3Vic2NyaWJlKHRoaXMuY2hlY2tBbmRQcm9wYWdhdGUuYmluZCh0aGlzKSk7XG4gIH1cblxuICBibHVyKCkge1xuICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgLy8gTm93IHRoYXQgd2UndmUgbG9zdCBmb2N1cywgc3RvcCBwcm9wYWdhdGluZyBjaGFuZ2VzLlxuICAgIGlmICh0aGlzLnNlbGVjdGVkVmFsdWVTdWIpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZVN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvLyBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoZSB1c2VyIGhhcyBqdXN0IHR5cGVkIHNvbWUgdGV4dCB0aGF0IHdpbGwgYmVcbiAgICAvLyBjb25maXJtZWQgKGJ5IHRoZSBhcHBsaWNhdGlvbiBwcm92aWRlZCBmdW5jdGlvbikgYXMgYSBtYXRjaCxcbiAgICAvLyBhc3luY2hyb25vdXNseS4gV2UgY2FuJ3QgZm9yY2UgdGhlIHN5c3RlbSB0byB3YWl0IGZvciB0aGF0IHRvIGhhcHBlbiwgd2VcbiAgICAvLyBhcmUgbG9zaW5nIGZvY3VzIHJpZ2h0IG5vdy4gQnV0IHdlIGNhbiBzdWJzY3JpYmUgdG8gcGljayB1cCB0aGF0IG9uZSBsYXN0XG4gICAgLy8gY2hhbmdlIGFuZCBwcm9wYWdhdGUgaXQgaWYvd2hlbiBpdCBhcnJpdmVzLlxuICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZVxuICAgICAgLnBpcGUodGFrZSgxKSlcbiAgICAgIC5zdWJzY3JpYmUodGhpcy5jaGVja0FuZFByb3BhZ2F0ZS5iaW5kKHRoaXMpKTtcbiAgICAvLyBIb3dldmVyLCB0aGlzIGNvZGUgcmFpc2VzIGFuIGltcG9ydGFudCBxdWVzdGlvbiBhYm91dCB2YWxpZCBiZWhhdmlvciBvZiBhXG4gICAgLy8gQW5ndWxhciBmb3JtIGNvbnRyb2wuIElzIGl0IGFjY2VwdGFibGUgZm9yIGEgZm9ybSBjb250cm9sIHRvXG4gICAgLy8gYXN5bmNocm9ub3VzbHkgcHJvdmlkZSBhIG5ldyB2YWx1ZSB3aGVuIGl0IG5vIGxvbmdlciBoYXMgZm9jdXM/XG4gIH1cblxuICBkaXNwbGF5V2l0aCh2YWx1ZTogT3B0aW9uRW50cnkpOiBzdHJpbmcge1xuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLmRpc3BsYXkgOiAnJztcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBJbnRlcm5hbHNcbiAgLy8gdHNsaW50OmRpc2FibGU6bWVtYmVyLW9yZGVyaW5nXG4gIHByaXZhdGUgaW5jb21pbmdWYWx1ZXMgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHByaXZhdGUgaW5jb21pbmdEYXRhU291cmNlcyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0YVNvdXJjZT4oe1xuICAgIGRpc3BsYXlWYWx1ZTogb2YsXG4gICAgc2VhcmNoOiAoKSA9PiBvZihbXSlcbiAgfSk7XG5cbiAgcHJpdmF0ZSBpbmNvbWluZ0RhdGFTb3VyY2VzU3ViOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgb3V0c2lkZVZhbHVlOiBhbnk7XG4gIHByaXZhdGUgc2VsZWN0ZWRWYWx1ZVN1YjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIHNlbGVjdGVkVmFsdWU6IE9ic2VydmFibGU8YW55PjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBzZWFyY2hlczogT2JzZXJ2YWJsZTxPcHRpb25FbnRyeSB8IHN0cmluZyB8IG51bGw+ID1cbiAgICAgIHRoaXMuc2VhcmNoQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShcbiAgICAgICAgc3RhcnRXaXRoKHRoaXMuc2VhcmNoQ29udHJvbC52YWx1ZSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgIGRlYm91bmNlKHNyY2ggPT4ge1xuICAgICAgICAgIC8vIFR5cGluZyBpbnRvIGlucHV0IHNlbmRzIHN0cmluZ3MuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzcmNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyKHRoaXMuZGVib3VuY2VUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEVNUFRZOyAvLyBpbW1lZGlhdGUgLSBubyBkZWJvdW5jZSBmb3IgY2hvb3NpbmcgZnJvbSB0aGUgbGlzdFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIGNvbnN0IG9wdGlvbnM6IE9ic2VydmFibGU8U2VhcmNoUmVzdWx0PiA9IGNvbWJpbmVMYXRlc3QoXG4gICAgICBzZWFyY2hlcyxcbiAgICAgIHRoaXMuaW5jb21pbmdEYXRhU291cmNlcy5waXBlKGZpbHRlcihkcyA9PiAhIWRzKSksXG4gICAgKS5waXBlKFxuICAgICAgc3dpdGNoTWFwKChbc3JjaCwgZHNdKSA9PiB7XG4gICAgICAgIC8vIEluaXRpYWwgdmFsdWUgaXMgc29tZXRpbWVzIG51bGwuXG4gICAgICAgIGlmIChzcmNoID09PSBudWxsKSB7XG4gICAgICAgICAgc3JjaCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGluZyBpbnRvIGlucHV0IHNlbmRzIHN0cmluZ3MuXG4gICAgICAgIGlmICh0eXBlb2Ygc3JjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCBzZWFyY2g6IHN0cmluZyA9IHNyY2g7XG4gICAgICAgICAgcmV0dXJuIGRzLnNlYXJjaChzcmNoKS5waXBlKFxuICAgICAgICAgICAgbWFwKGxpc3QgPT4gKHsgc2VhcmNoLCBsaXN0IH0pKSxcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3JNZXNzYWdlID0+IG9mKHsgc2VhcmNoLCBlcnJvck1lc3NhZ2UgfSkpLFxuICAgICAgICAgICAgc3RhcnRXaXRoKHsgc2VhcmNoIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdGluZyBmcm9tIE1hdGVyaWFsIE9wdGlvbiBMaXN0IHNlbmRzIGFuIG9iamVjdCwgc28gdGhlcmUgaXNcbiAgICAgICAgLy8gbm8gbmVlZCB0byBjYWxsIGZ1bmN0aW9uIHRvIHNlYXJjaCBmb3IgaXQuXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gc3JjaCBhcyBPcHRpb25FbnRyeTtcbiAgICAgICAgcmV0dXJuIG9mPFNlYXJjaFJlc3VsdD4oe1xuICAgICAgICAgIHNlYXJjaDogc3JjaC5kaXNwbGF5LFxuICAgICAgICAgIGxpc3Q6IFt7IC4uLmVudHJ5IH1dXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBwdWJsaXNoUmVwbGF5KDEpLFxuICAgICAgcmVmQ291bnQoKVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBtYXRjaGVyKHNlYXJjaDogc3RyaW5nLCBlbnRyeTogT3B0aW9uRW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5kaXNwbGF5ID09PSBzZWFyY2g7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gb3B0aW9ucy5waXBlKFxuICAgICAgZmlsdGVyKHJlc3VsdCA9PiAhIXJlc3VsdC5saXN0KSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuaW5jb21pbmdEYXRhU291cmNlcyksXG4gICAgICBtYXAoKFtyZXN1bHQsIGRzXSkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ID0gcmVzdWx0Lmxpc3QgfHwgW107IC8vIGFwcGVhc2UgVFNcbiAgICAgICAgY29uc3QgbWF0Y2hGbiA9IGRzLm1hdGNoIHx8IG1hdGNoZXI7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbGlzdC5maW5kKG9wdGlvbiA9PiBtYXRjaEZuKHJlc3VsdC5zZWFyY2gsIG9wdGlvbikpO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWUgfHwgbnVsbDtcbiAgICAgIH0pLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICk7XG5cbiAgICB0aGlzLmxvYWRpbmcgPSBvcHRpb25zLnBpcGUobWFwKG8gPT4gIW8ubGlzdCAmJiAhby5lcnJvck1lc3NhZ2UpKTtcbiAgICB0aGlzLmxpc3QgPSBvcHRpb25zLnBpcGUobWFwKG8gPT4gby5saXN0KSk7XG4gICAgdGhpcy5lbXB0eSA9IG9wdGlvbnMucGlwZShtYXAobyA9PiBvLmxpc3QgPyBvLmxpc3QubGVuZ3RoID09PSAwIDogZmFsc2UpKTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG9wdGlvbnMucGlwZShtYXAobyA9PiBvLmVycm9yTWVzc2FnZSkpO1xuXG4gICAgLy8gYSB2YWx1ZSB3YXMgcHJvdmlkZWQgYnkgdGhlIGZvcm07IHJlcXVlc3QgdGhlIGZ1bGwgZW50cnlcbiAgICB0aGlzLmluY29taW5nRGF0YVNvdXJjZXNTdWIgPSB0aGlzLmluY29taW5nVmFsdWVzLnBpcGUoXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLmluY29taW5nRGF0YVNvdXJjZXMpLFxuICAgICAgc3dpdGNoTWFwPFthbnksIERhdGFTb3VyY2VdLCBPYnNlcnZhYmxlPE9wdGlvbkVudHJ5IHwgbnVsbD4+KChbdmFsdWUsIGRzXSkgPT4gZHMuZGlzcGxheVZhbHVlKHZhbHVlKSlcbiAgICApXG4gICAgICAuc3Vic2NyaWJlKHZhbHVlID0+IHRoaXMuc2VhcmNoQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50IENvbnRyb2xWYWx1ZUFjY2Vzc29yXG5cbiAgd3JpdGVWYWx1ZShvYmo6IGFueSk6IHZvaWQge1xuICAgIC8vIEFuZ3VsYXIgc29tZXRpbWVzIHdyaXRlcyBhIHZhbHVlIHRoYXQgZGlkbid0IHJlYWxseSBjaGFuZ2UuXG4gICAgaWYgKG9iaiAhPT0gdGhpcy5vdXRzaWRlVmFsdWUpIHtcbiAgICAgIHRoaXMub3V0c2lkZVZhbHVlID0gb2JqO1xuICAgICAgdGhpcy5pbmNvbWluZ1ZhbHVlcy5uZXh0KG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gIH1cblxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5zZWFyY2hDb250cm9sLmRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWFyY2hDb250cm9sLmVuYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmluY29taW5nRGF0YVNvdXJjZXNTdWIpIHtcbiAgICAgIHRoaXMuaW5jb21pbmdEYXRhU291cmNlc1N1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG4gIHByaXZhdGUgb25Ub3VjaGVkID0gKCkgPT4geyB9O1xuXG4gIHByaXZhdGUgY2hlY2tBbmRQcm9wYWdhdGUodmFsdWU6IGFueSkge1xuICAgIC8vIE9ubHkgc2VuZCBhIGNoYW5nZSBpZiB0aGVyZSByZWFsbHkgaXMgb25lLlxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5vdXRzaWRlVmFsdWUpIHtcbiAgICAgIHRoaXMub3V0c2lkZVZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==