import * as tslib_1 from "tslib";
import { Component, Input, ViewEncapsulation, ChangeDetectionStrategy, forwardRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { SearchSelectBase } from './base';
// The CSS approach below is the documented solution:
// https://github.com/angular/material2/issues/3810
// https://github.com/angular/material2/pull/7176
// To set the width, style the first class something like this:
// width: 400px;
// max-width: 400px !important;
// ... need to figure out how to set the number programmaticlly.
var SearchSelectComponent = /** @class */ (function (_super) {
    tslib_1.__extends(SearchSelectComponent, _super);
    function SearchSelectComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.debounceTime = 100;
        _this.width = '';
        _this.emptyText = '';
        _this.autoActiveFirstOption = false;
        return _this;
    }
    SearchSelectComponent_1 = SearchSelectComponent;
    var SearchSelectComponent_1;
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], SearchSelectComponent.prototype, "placeholder", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "debounceTime", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "width", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "emptyText", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], SearchSelectComponent.prototype, "autoActiveFirstOption", void 0);
    SearchSelectComponent = SearchSelectComponent_1 = tslib_1.__decorate([
        Component({
            selector: 'search-select',
            template: "<mat-form-field class=\"obs-mat-container\" [style.width]=\"width\">\n  <mat-spinner class=\"obs-mat-spinner\"\n    *ngIf=\"loading | async\"\n    [diameter]=\"20\"\n    [strokeWidth]=\"5\"></mat-spinner>\n  <i class=\"obs-no-matches\" *ngIf=\"emptyText && empty | async\">{{emptyText}}</i>\n  <input\n      type=\"text\"\n      [placeholder]=\"placeholder\"\n      [attr.aria-label]=\"placeholder\"\n      spellcheck=\"false\"\n      matInput\n      [formControl]=\"searchControl\"\n      #input\n      (blur)=\"blur()\"\n      (focus)=\"input.select(); focus()\"\n      [matAutocomplete]=\"auto\">\n  <mat-autocomplete #auto=\"matAutocomplete\" [displayWith]=\"displayWith\"\n    [autoActiveFirstOption]=\"autoActiveFirstOption\"\n   class=\"bigger-mat-ac\">\n    <mat-option *ngFor=\"let option of list | async\"\n      [value]=\"option\">\n      {{ option.display }}\n    </mat-option>\n  </mat-autocomplete>\n  <b>{{ errorMessage | async }}</b>\n</mat-form-field>\n",
            providers: [
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return SearchSelectComponent_1; }),
                    multi: true
                }
            ],
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [".bigger-mat-ac.mat-autocomplete-panel{max-height:500px!important}.obs-mat-container{position:relative}.obs-mat-container mat-spinner.obs-mat-spinner{position:absolute;right:5px}.obs-no-matches{position:absolute;color:silver;right:5px}.ng-invalid.ng-touched>.obs-mat-container,.ng-invalid.ng-touched>.obs-mat-container label{color:#f44336!important}"]
        })
    ], SearchSelectComponent);
    return SearchSelectComponent;
}(SearchSelectBase));
export { SearchSelectComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLXNlbGVjdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ab2FzaXNkaWdpdGFsL2FuZ3VsYXItbWF0ZXJpYWwtc2VhcmNoLXNlbGVjdC8iLCJzb3VyY2VzIjpbInNlYXJjaC1zZWxlY3QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSx1QkFBdUIsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekcsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFbkQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRTFDLHFEQUFxRDtBQUNyRCxtREFBbUQ7QUFDbkQsaURBQWlEO0FBRWpELCtEQUErRDtBQUMvRCxnQkFBZ0I7QUFDaEIsK0JBQStCO0FBQy9CLGdFQUFnRTtBQWdCaEU7SUFBMkMsaURBQWdCO0lBZDNEO1FBQUEscUVBb0JDO1FBSlUsa0JBQVksR0FBRyxHQUFHLENBQUM7UUFDbkIsV0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNYLGVBQVMsR0FBRyxFQUFFLENBQUM7UUFDZiwyQkFBcUIsR0FBRyxLQUFLLENBQUM7O0lBQ3pDLENBQUM7OEJBTlkscUJBQXFCOztJQUN2QjtRQUFSLEtBQUssRUFBRTs7OERBQXFCO0lBQ3BCO1FBQVIsS0FBSyxFQUFFOzsrREFBb0I7SUFDbkI7UUFBUixLQUFLLEVBQUU7O3dEQUFZO0lBQ1g7UUFBUixLQUFLLEVBQUU7OzREQUFnQjtJQUNmO1FBQVIsS0FBSyxFQUFFOzt3RUFBK0I7SUFMNUIscUJBQXFCO1FBZGpDLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxlQUFlO1lBQ3pCLHM5QkFBNkM7WUFFN0MsU0FBUyxFQUFFO2dCQUNUO29CQUNFLE9BQU8sRUFBRSxpQkFBaUI7b0JBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsY0FBTSxPQUFBLHVCQUFxQixFQUFyQixDQUFxQixDQUFDO29CQUNwRCxLQUFLLEVBQUUsSUFBSTtpQkFDWjthQUNGO1lBQ0QsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7WUFDckMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O1NBQ2hELENBQUM7T0FDVyxxQkFBcUIsQ0FNakM7SUFBRCw0QkFBQztDQUFBLEFBTkQsQ0FBMkMsZ0JBQWdCLEdBTTFEO1NBTlkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgVmlld0VuY2Fwc3VsYXRpb24sIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgU2VhcmNoU2VsZWN0QmFzZSB9IGZyb20gJy4vYmFzZSc7XG5cbi8vIFRoZSBDU1MgYXBwcm9hY2ggYmVsb3cgaXMgdGhlIGRvY3VtZW50ZWQgc29sdXRpb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9tYXRlcmlhbDIvaXNzdWVzLzM4MTBcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9wdWxsLzcxNzZcblxuLy8gVG8gc2V0IHRoZSB3aWR0aCwgc3R5bGUgdGhlIGZpcnN0IGNsYXNzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vLyB3aWR0aDogNDAwcHg7XG4vLyBtYXgtd2lkdGg6IDQwMHB4ICFpbXBvcnRhbnQ7XG4vLyAuLi4gbmVlZCB0byBmaWd1cmUgb3V0IGhvdyB0byBzZXQgdGhlIG51bWJlciBwcm9ncmFtbWF0aWNsbHkuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3NlYXJjaC1zZWxlY3QnLFxuICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLXNlbGVjdC5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3NlYXJjaC1zZWxlY3QuY29tcG9uZW50LmNzcyddLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNlYXJjaFNlbGVjdENvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZVxuICAgIH1cbiAgXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoU2VsZWN0Q29tcG9uZW50IGV4dGVuZHMgU2VhcmNoU2VsZWN0QmFzZSB7XG4gIEBJbnB1dCgpIHBsYWNlaG9sZGVyOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGRlYm91bmNlVGltZSA9IDEwMDtcbiAgQElucHV0KCkgd2lkdGggPSAnJztcbiAgQElucHV0KCkgZW1wdHlUZXh0ID0gJyc7XG4gIEBJbnB1dCgpIGF1dG9BY3RpdmVGaXJzdE9wdGlvbiA9IGZhbHNlO1xufVxuIl19