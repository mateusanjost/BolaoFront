import { __decorate, __metadata } from 'tslib';
import { Input, Component, forwardRef, ViewEncapsulation, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatAutocompleteModule, MatFormFieldModule, MatInputModule, MatProgressSpinnerModule, MatTooltipModule } from '@angular/material';
import { Subject, BehaviorSubject, of, timer, EMPTY, combineLatest } from 'rxjs';
import { startWith, distinctUntilChanged, debounce, filter, switchMap, map, catchError, publishReplay, refCount, withLatestFrom, take } from 'rxjs/operators';

// Base class with which to create an observable auto complete. This doesn't
class SearchSelectBase {
    constructor() {
        this.debounceTime = 75;
        // API provided to client component (for use in its template)
        this.searchControl = new FormControl();
        // ---------------------------------------------------------------------
        // Internals
        // tslint:disable:member-ordering
        this.incomingValues = new Subject();
        this.incomingDataSources = new BehaviorSubject({
            displayValue: of,
            search: () => of([])
        });
        this.onChange = (_) => { };
        this.onTouched = () => { };
        const searches = this.searchControl.valueChanges.pipe(startWith(this.searchControl.value), distinctUntilChanged(), debounce(srch => {
            // Typing into input sends strings.
            if (typeof srch === 'string') {
                return timer(this.debounceTime);
            }
            return EMPTY; // immediate - no debounce for choosing from the list
        }));
        const options = combineLatest(searches, this.incomingDataSources.pipe(filter(ds => !!ds))).pipe(switchMap(([srch, ds]) => {
            // Initial value is sometimes null.
            if (srch === null) {
                srch = '';
            }
            // Typing into input sends strings.
            if (typeof srch === 'string') {
                const search = srch;
                return ds.search(srch).pipe(map(list => ({ search, list })), catchError(errorMessage => of({ search, errorMessage })), startWith({ search }));
            }
            // Selecting from Material Option List sends an object, so there is
            // no need to call function to search for it.
            const entry = srch;
            return of({
                search: srch.display,
                list: [Object.assign({}, entry)]
            });
        }), publishReplay(1), refCount());
        function matcher(search, entry) {
            return entry.display === search;
        }
        this.selectedValue = options.pipe(filter(result => !!result.list), withLatestFrom(this.incomingDataSources), map(([result, ds]) => {
            const list = result.list || []; // appease TS
            const matchFn = ds.match || matcher;
            const entry = list.find(option => matchFn(result.search, option));
            return entry && entry.value || null;
        }), distinctUntilChanged());
        this.loading = options.pipe(map(o => !o.list && !o.errorMessage));
        this.list = options.pipe(map(o => o.list));
        this.empty = options.pipe(map(o => o.list ? o.list.length === 0 : false));
        this.errorMessage = options.pipe(map(o => o.errorMessage));
        // a value was provided by the form; request the full entry
        this.incomingDataSourcesSub = this.incomingValues.pipe(withLatestFrom(this.incomingDataSources), switchMap(([value, ds]) => ds.displayValue(value)))
            .subscribe(value => this.searchControl.setValue(value));
    }
    set dataSource(ds) { this.incomingDataSources.next(ds); }
    focus() {
        // While focused, user selection will be propagated to the form.
        this.selectedValueSub = this.selectedValue.subscribe(this.checkAndPropagate.bind(this));
    }
    blur() {
        this.onTouched();
        // Now that we've lost focus, stop propagating changes.
        if (this.selectedValueSub) {
            this.selectedValueSub.unsubscribe();
        }
        // However, it's possible the user has just typed some text that will be
        // confirmed (by the application provided function) as a match,
        // asynchronously. We can't force the system to wait for that to happen, we
        // are losing focus right now. But we can subscribe to pick up that one last
        // change and propagate it if/when it arrives.
        this.selectedValue
            .pipe(take(1))
            .subscribe(this.checkAndPropagate.bind(this));
        // However, this code raises an important question about valid behavior of a
        // Angular form control. Is it acceptable for a form control to
        // asynchronously provide a new value when it no longer has focus?
    }
    displayWith(value) {
        return value ? value.display : '';
    }
    // Implement ControlValueAccessor
    writeValue(obj) {
        // Angular sometimes writes a value that didn't really change.
        if (obj !== this.outsideValue) {
            this.outsideValue = obj;
            this.incomingValues.next(obj);
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.searchControl.disable();
        }
        else {
            this.searchControl.enable();
        }
    }
    ngOnDestroy() {
        if (this.incomingDataSourcesSub) {
            this.incomingDataSourcesSub.unsubscribe();
        }
    }
    checkAndPropagate(value) {
        // Only send a change if there really is one.
        if (value !== this.outsideValue) {
            this.outsideValue = value;
            this.onChange(value);
        }
    }
}
__decorate([
    Input(),
    __metadata("design:type", Object)
], SearchSelectBase.prototype, "debounceTime", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], SearchSelectBase.prototype, "dataSource", null);

var SearchSelectComponent_1;
// The CSS approach below is the documented solution:
// https://github.com/angular/material2/issues/3810
// https://github.com/angular/material2/pull/7176
// To set the width, style the first class something like this:
// width: 400px;
// max-width: 400px !important;
// ... need to figure out how to set the number programmaticlly.
let SearchSelectComponent = SearchSelectComponent_1 = class SearchSelectComponent extends SearchSelectBase {
    // The CSS approach below is the documented solution:
    // https://github.com/angular/material2/issues/3810
    // https://github.com/angular/material2/pull/7176
    // To set the width, style the first class something like this:
    // width: 400px;
    // max-width: 400px !important;
    // ... need to figure out how to set the number programmaticlly.
    constructor() {
        super(...arguments);
        this.debounceTime = 100;
        this.width = '';
        this.emptyText = '';
        this.autoActiveFirstOption = false;
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], SearchSelectComponent.prototype, "placeholder", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SearchSelectComponent.prototype, "debounceTime", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SearchSelectComponent.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SearchSelectComponent.prototype, "emptyText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SearchSelectComponent.prototype, "autoActiveFirstOption", void 0);
SearchSelectComponent = SearchSelectComponent_1 = __decorate([
    Component({
        selector: 'search-select',
        template: "<mat-form-field class=\"obs-mat-container\" [style.width]=\"width\">\n  <mat-spinner class=\"obs-mat-spinner\"\n    *ngIf=\"loading | async\"\n    [diameter]=\"20\"\n    [strokeWidth]=\"5\"></mat-spinner>\n  <i class=\"obs-no-matches\" *ngIf=\"emptyText && empty | async\">{{emptyText}}</i>\n  <input\n      type=\"text\"\n      [placeholder]=\"placeholder\"\n      [attr.aria-label]=\"placeholder\"\n      spellcheck=\"false\"\n      matInput\n      [formControl]=\"searchControl\"\n      #input\n      (blur)=\"blur()\"\n      (focus)=\"input.select(); focus()\"\n      [matAutocomplete]=\"auto\">\n  <mat-autocomplete #auto=\"matAutocomplete\" [displayWith]=\"displayWith\"\n    [autoActiveFirstOption]=\"autoActiveFirstOption\"\n   class=\"bigger-mat-ac\">\n    <mat-option *ngFor=\"let option of list | async\"\n      [value]=\"option\">\n      {{ option.display }}\n    </mat-option>\n  </mat-autocomplete>\n  <b>{{ errorMessage | async }}</b>\n</mat-form-field>\n",
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => SearchSelectComponent_1),
                multi: true
            }
        ],
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".bigger-mat-ac.mat-autocomplete-panel{max-height:500px!important}.obs-mat-container{position:relative}.obs-mat-container mat-spinner.obs-mat-spinner{position:absolute;right:5px}.obs-no-matches{position:absolute;color:silver;right:5px}.ng-invalid.ng-touched>.obs-mat-container,.ng-invalid.ng-touched>.obs-mat-container label{color:#f44336!important}"]
    })
], SearchSelectComponent);

let SearchSelectModule = class SearchSelectModule {
};
SearchSelectModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            MatAutocompleteModule,
            MatFormFieldModule,
            MatInputModule,
            MatProgressSpinnerModule,
            MatTooltipModule,
            FormsModule,
            ReactiveFormsModule
        ],
        declarations: [
            SearchSelectComponent
        ],
        exports: [
            SearchSelectComponent
        ]
    })
], SearchSelectModule);

/**
 * Generated bundle index. Do not edit.
 */

export { SearchSelectBase, SearchSelectModule, SearchSelectComponent as Éµa };
//# sourceMappingURL=oasisdigital-angular-material-search-select.js.map
