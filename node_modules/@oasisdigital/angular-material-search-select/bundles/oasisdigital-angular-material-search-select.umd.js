(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@angular/material'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@oasisdigital/angular-material-search-select', ['exports', '@angular/core', '@angular/common', '@angular/forms', '@angular/material', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.oasisdigital = global.oasisdigital || {}, global.oasisdigital['angular-material-search-select'] = {}), global.ng.core, global.ng.common, global.ng.forms, global.ng.material, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, common, forms, material, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    // Base class with which to create an observable auto complete. This doesn't
    var SearchSelectBase = /** @class */ (function () {
        function SearchSelectBase() {
            var _this = this;
            this.debounceTime = 75;
            // API provided to client component (for use in its template)
            this.searchControl = new forms.FormControl();
            // ---------------------------------------------------------------------
            // Internals
            // tslint:disable:member-ordering
            this.incomingValues = new rxjs.Subject();
            this.incomingDataSources = new rxjs.BehaviorSubject({
                displayValue: rxjs.of,
                search: function () { return rxjs.of([]); }
            });
            this.onChange = function (_) { };
            this.onTouched = function () { };
            var searches = this.searchControl.valueChanges.pipe(operators.startWith(this.searchControl.value), operators.distinctUntilChanged(), operators.debounce(function (srch) {
                // Typing into input sends strings.
                if (typeof srch === 'string') {
                    return rxjs.timer(_this.debounceTime);
                }
                return rxjs.EMPTY; // immediate - no debounce for choosing from the list
            }));
            var options = rxjs.combineLatest(searches, this.incomingDataSources.pipe(operators.filter(function (ds) { return !!ds; }))).pipe(operators.switchMap(function (_a) {
                var _b = __read(_a, 2), srch = _b[0], ds = _b[1];
                // Initial value is sometimes null.
                if (srch === null) {
                    srch = '';
                }
                // Typing into input sends strings.
                if (typeof srch === 'string') {
                    var search_1 = srch;
                    return ds.search(srch).pipe(operators.map(function (list) { return ({ search: search_1, list: list }); }), operators.catchError(function (errorMessage) { return rxjs.of({ search: search_1, errorMessage: errorMessage }); }), operators.startWith({ search: search_1 }));
                }
                // Selecting from Material Option List sends an object, so there is
                // no need to call function to search for it.
                var entry = srch;
                return rxjs.of({
                    search: srch.display,
                    list: [__assign({}, entry)]
                });
            }), operators.publishReplay(1), operators.refCount());
            function matcher(search, entry) {
                return entry.display === search;
            }
            this.selectedValue = options.pipe(operators.filter(function (result) { return !!result.list; }), operators.withLatestFrom(this.incomingDataSources), operators.map(function (_a) {
                var _b = __read(_a, 2), result = _b[0], ds = _b[1];
                var list = result.list || []; // appease TS
                var matchFn = ds.match || matcher;
                var entry = list.find(function (option) { return matchFn(result.search, option); });
                return entry && entry.value || null;
            }), operators.distinctUntilChanged());
            this.loading = options.pipe(operators.map(function (o) { return !o.list && !o.errorMessage; }));
            this.list = options.pipe(operators.map(function (o) { return o.list; }));
            this.empty = options.pipe(operators.map(function (o) { return o.list ? o.list.length === 0 : false; }));
            this.errorMessage = options.pipe(operators.map(function (o) { return o.errorMessage; }));
            // a value was provided by the form; request the full entry
            this.incomingDataSourcesSub = this.incomingValues.pipe(operators.withLatestFrom(this.incomingDataSources), operators.switchMap(function (_a) {
                var _b = __read(_a, 2), value = _b[0], ds = _b[1];
                return ds.displayValue(value);
            }))
                .subscribe(function (value) { return _this.searchControl.setValue(value); });
        }
        Object.defineProperty(SearchSelectBase.prototype, "dataSource", {
            set: function (ds) { this.incomingDataSources.next(ds); },
            enumerable: true,
            configurable: true
        });
        SearchSelectBase.prototype.focus = function () {
            // While focused, user selection will be propagated to the form.
            this.selectedValueSub = this.selectedValue.subscribe(this.checkAndPropagate.bind(this));
        };
        SearchSelectBase.prototype.blur = function () {
            this.onTouched();
            // Now that we've lost focus, stop propagating changes.
            if (this.selectedValueSub) {
                this.selectedValueSub.unsubscribe();
            }
            // However, it's possible the user has just typed some text that will be
            // confirmed (by the application provided function) as a match,
            // asynchronously. We can't force the system to wait for that to happen, we
            // are losing focus right now. But we can subscribe to pick up that one last
            // change and propagate it if/when it arrives.
            this.selectedValue
                .pipe(operators.take(1))
                .subscribe(this.checkAndPropagate.bind(this));
            // However, this code raises an important question about valid behavior of a
            // Angular form control. Is it acceptable for a form control to
            // asynchronously provide a new value when it no longer has focus?
        };
        SearchSelectBase.prototype.displayWith = function (value) {
            return value ? value.display : '';
        };
        // Implement ControlValueAccessor
        SearchSelectBase.prototype.writeValue = function (obj) {
            // Angular sometimes writes a value that didn't really change.
            if (obj !== this.outsideValue) {
                this.outsideValue = obj;
                this.incomingValues.next(obj);
            }
        };
        SearchSelectBase.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        SearchSelectBase.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        SearchSelectBase.prototype.setDisabledState = function (isDisabled) {
            if (isDisabled) {
                this.searchControl.disable();
            }
            else {
                this.searchControl.enable();
            }
        };
        SearchSelectBase.prototype.ngOnDestroy = function () {
            if (this.incomingDataSourcesSub) {
                this.incomingDataSourcesSub.unsubscribe();
            }
        };
        SearchSelectBase.prototype.checkAndPropagate = function (value) {
            // Only send a change if there really is one.
            if (value !== this.outsideValue) {
                this.outsideValue = value;
                this.onChange(value);
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SearchSelectBase.prototype, "debounceTime", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], SearchSelectBase.prototype, "dataSource", null);
        return SearchSelectBase;
    }());

    // The CSS approach below is the documented solution:
    // https://github.com/angular/material2/issues/3810
    // https://github.com/angular/material2/pull/7176
    // To set the width, style the first class something like this:
    // width: 400px;
    // max-width: 400px !important;
    // ... need to figure out how to set the number programmaticlly.
    var SearchSelectComponent = /** @class */ (function (_super) {
        __extends(SearchSelectComponent, _super);
        function SearchSelectComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.debounceTime = 100;
            _this.width = '';
            _this.emptyText = '';
            _this.autoActiveFirstOption = false;
            return _this;
        }
        SearchSelectComponent_1 = SearchSelectComponent;
        var SearchSelectComponent_1;
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], SearchSelectComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SearchSelectComponent.prototype, "debounceTime", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SearchSelectComponent.prototype, "width", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SearchSelectComponent.prototype, "emptyText", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], SearchSelectComponent.prototype, "autoActiveFirstOption", void 0);
        SearchSelectComponent = SearchSelectComponent_1 = __decorate([
            core.Component({
                selector: 'search-select',
                template: "<mat-form-field class=\"obs-mat-container\" [style.width]=\"width\">\n  <mat-spinner class=\"obs-mat-spinner\"\n    *ngIf=\"loading | async\"\n    [diameter]=\"20\"\n    [strokeWidth]=\"5\"></mat-spinner>\n  <i class=\"obs-no-matches\" *ngIf=\"emptyText && empty | async\">{{emptyText}}</i>\n  <input\n      type=\"text\"\n      [placeholder]=\"placeholder\"\n      [attr.aria-label]=\"placeholder\"\n      spellcheck=\"false\"\n      matInput\n      [formControl]=\"searchControl\"\n      #input\n      (blur)=\"blur()\"\n      (focus)=\"input.select(); focus()\"\n      [matAutocomplete]=\"auto\">\n  <mat-autocomplete #auto=\"matAutocomplete\" [displayWith]=\"displayWith\"\n    [autoActiveFirstOption]=\"autoActiveFirstOption\"\n   class=\"bigger-mat-ac\">\n    <mat-option *ngFor=\"let option of list | async\"\n      [value]=\"option\">\n      {{ option.display }}\n    </mat-option>\n  </mat-autocomplete>\n  <b>{{ errorMessage | async }}</b>\n</mat-form-field>\n",
                providers: [
                    {
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: core.forwardRef(function () { return SearchSelectComponent_1; }),
                        multi: true
                    }
                ],
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".bigger-mat-ac.mat-autocomplete-panel{max-height:500px!important}.obs-mat-container{position:relative}.obs-mat-container mat-spinner.obs-mat-spinner{position:absolute;right:5px}.obs-no-matches{position:absolute;color:silver;right:5px}.ng-invalid.ng-touched>.obs-mat-container,.ng-invalid.ng-touched>.obs-mat-container label{color:#f44336!important}"]
            })
        ], SearchSelectComponent);
        return SearchSelectComponent;
    }(SearchSelectBase));

    var SearchSelectModule = /** @class */ (function () {
        function SearchSelectModule() {
        }
        SearchSelectModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    material.MatAutocompleteModule,
                    material.MatFormFieldModule,
                    material.MatInputModule,
                    material.MatProgressSpinnerModule,
                    material.MatTooltipModule,
                    forms.FormsModule,
                    forms.ReactiveFormsModule
                ],
                declarations: [
                    SearchSelectComponent
                ],
                exports: [
                    SearchSelectComponent
                ]
            })
        ], SearchSelectModule);
        return SearchSelectModule;
    }());

    exports.SearchSelectBase = SearchSelectBase;
    exports.SearchSelectModule = SearchSelectModule;
    exports.Éµa = SearchSelectComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=oasisdigital-angular-material-search-select.umd.js.map
